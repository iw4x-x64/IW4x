d = $config.libiw4x.doxygen

# Define the file types.
#
# We distinguish between the configuration input and the tagfile/XML output
# to properly model the dependency graph.
#
define doxygen: file
doxygen{*}: extension = doxygen

define doxytag: file
doxytag{*}: extension = doxytag

# Import the tool.
#
# Note that we guard this with $develop to avoid triggering the requirement
# in distribution builds.
#
if $d
  import! doxygen = doxygen%exe{doxygen}

# Root-level target.
#
# Similar to the import, we only include this in the develop build to avoid
# enforcing documentation generation on consumers of the package.
#
./: doxytag{libiw4x}: include = $d

# The Doxygen generation recipe.
#
# While the tagfile is the nominal target here, we are primarily interested
# in the side effect: the directory full of XML files.
#
<doxytag{libiw4x}>: doxygen{libiw4x}                     \
                    $src_root/../libiw4x/libiw4x/hxx{**} \
                    $doxygen
%
if $d
{{
  o = $directory($>[0])    # Target output directory.
  c = $path($<[0])         # Source config file.
  t = $path($>[0]).t       # Temporary doxygen directory for dry-run.
  tc = $t/"$leaf($c)"      # Temporary doxygen config for dry-run.
  d = $t/$name($>[0]).d    # Dependency file we need to generate.

  # Doxygen is notoriously opaque about the files it generates. We cannot
  # ask it "what will you produce?" without actually letting it run.
  #
  # To handle this, we employ a "dry-run" strategy for dependency extraction
  # involving three steps:
  #
  # 1. Isolate: Create a temporary directory ($t) to act as a sandbox.
  #
  # 2. Mutate: Patch the configuration file on the fly to redirect
  #    XML_OUTPUT to the sandbox and disable tagfile generation (since we
  #    only care about the file list here).
  #
  # 3. Harvest: Run doxygen in the sandbox, list the resulting files, and
  #    normalize their paths to look like they came from the real output
  #    directory ($o).
  #
  depdb dyndep --dyn-target $dyndep_options --format lines --file $d -- \
    mkdir -p $t                                                      && \
    sed -e "s%^\\s*\(XML_OUTPUT\\s*=\).*\$%\\1 $t/xml%"                 \
        -e "s%^\\s*\(GENERATE_TAGFILE\\s*=\).*\$%\\1%"       $c >$tc && \
    $doxygen $tc &$t/xml/*** && \
    find $t/xml -type f                                          >$d && \
    sed -e "s%[/\\\\]$path.leaf($t)%%g"                        -i $d && \
    echo ''                                                     >>$d && \
    echo $path.representation([dir_path] $o/xml)                >>$d

  # Diagnostics.
  #
  # It is helpful to see where we are mapping from/to when debugging build
  # logic.
  #
  diag doxygen ($<[0]) -> ($>[0]) $o/fsdir{xml/}

  # Cleanup logic.
  #
  # Doxygen does not clean up stale files from previous runs (e.g., if a
  # class was renamed, the old hash file remains). This leaves garbage in
  # the XML directory. We have to wipe the slate clean before the real run.
  #
  rm -rf $o/xml

  # Finally, run the real generation using the original config.
  #
  $doxygen $c
}}

# Template processing.
#
# We need to inject the project root so the Doxygen config knows where to
# look for headers relative to the build directory.
#
doxygen{libiw4x.doxygen}: in{libiw4x.doxygen.in} $src_root/manifest
{
  in.symbol = '|'
  input = $src_root/../libiw4x/libiw4x/
}
